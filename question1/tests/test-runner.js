class e{async report(e){throw new Error("Implement method")}}class t extends e{async report(e){if(await e.passed())console.log(`%cAll tests for ${e.questionName} passed`,"background-color: darkgreen; color: white; padding:0 5px;");else{console.group(`%cSome tests for ${e.questionName} failed`,"background-color: darkred; color: white; padding:0 5px;");for(const t of await e.listFailed()){const e=`Input: ${t.inputsAsStrings.join(", ")}. Expected: ${await t.expected.formattedValue()}`;t.hasError?console.log(`${e}.\nExpection occured. See error data below\n`,t.error):console.log(`${e}. Actual: ${await t.formattedActual()}`)}console.groupEnd()}}}class s extends e{constructor(){if(super(),this.element=document.getElementById("tests"),this.element){let e=document.getElementById("htmlReporterStyles");e||(e=document.createElement("style"),e.setAttribute("id","htmlReporterStyles"),e.textContent="\n        .summary { display: flex; flex-direction: column; margin-bottom: 10px; }\n        .testsHeader { padding: 10px 20px; font-family: sans-serif; }\n        .success .testsHeader { background-color: darkgreen; color: white; }\n        .fail .testsHeader { background-color: darkred; color: white; }\n        .testCaseWrapper { font-family: monospace; font-size: 1rem; padding: 10px; background-color: lightgrey; gap: 5px 30px; display: grid; grid-template-columns: auto auto auto; }\n        .testCaseWrapper > span { white-space: pre; }\n        ",document.head.appendChild(e))}else console.warn("HTML reporter found no base element. Will not report anything.")}async report(e){if(!this.element)return;const t=await e.passed(),s=document.createElement("div");s.classList.add("summary",t?"success":"fail");const r=document.createElement("span");if(r.classList.add("testsHeader"),r.textContent=t?`${e.questionName}: All tests passed`:`${e.questionName}: some tests failed`,s.appendChild(r),!await e.passed()){const t=document.createElement("div");t.classList.add("testCaseWrapper");const r=document.createElement("span");r.textContent="Inputs",t.appendChild(r);const a=document.createElement("span");a.textContent="Expected",t.appendChild(a);const n=document.createElement("span");n.textContent="Actual",t.appendChild(n);for(const s of await e.listFailed()){const e=document.createElement("span");e.textContent=s.inputsAsStrings.join(", "),t.appendChild(e);const r=document.createElement("span");r.textContent=await s.expected.formattedValue(),t.appendChild(r);const a=document.createElement("span");s.hasError?a.textContent=`Expection occured. See error data below\n${JSON.stringify(s.error.message)}\n${JSON.stringify(s.error.stack)}`:a.textContent=await s.formattedActual(),t.appendChild(a)}s.appendChild(t)}this.element.appendChild(s)}}class r{constructor(e){this.value=e}}class a{constructor(e){this.value=e}}class n{constructor(e,t){this._value=e,this.type=t}get value(){return"promise-resolved"===this.type?Promise.resolve(this._value):"promise-rejected"===this.type?Promise.reject(this._value):this._value}get rawValue(){return this._value}}class o{constructor(e,t,s){this.value=e,this.check=t.bind(this),this.formatter=s}async formattedValue(){return this.formatter(this.value)}}const i=Symbol.for("TestCase.NoValue");class c{constructor(e,...t){this.expected=e,this._inputs=t,this.actual=i,this.storedPassed=i,this.error=i}async formattedActual(){return this.actual===i?"no value found":await this.expected.formatter(this.actual)}get hasError(){return this.error!==i}get inputs(){return this._inputs.map((e=>e instanceof n?e.value:e))}get inputsAsStrings(){return this._inputs.map((e=>{if(e instanceof n){if("promise-resolved"===e.type)return`Fulfilled promise(${e.rawValue})`;if("promise-rejected"===e.type)return`Rejected promise(${e.rawValue})`;if("callback"===e.type){return`callback(${e._value.params.map((e=>"object"==typeof e?JSON.stringify(e):`${e}`)).join(", ")})`}return"object"==typeof e.value?JSON.stringify(e.value):e.value}return"object"==typeof e?JSON.stringify(e):e}))}async passed(){return this.storedPassed!==i?this.storedPassed:this.error!==i?(this.storedPassed=!1,!1):(this.storedPassed=await this.expected.check(this.actual),this.storedPassed)}}class l{constructor(e,t){this.questionName=e,this.testCases=t}async passed(){return this.testCases.reduce((async(e,t)=>{const s=await e,r=await t.passed();return s&&r}),!0)}async listFailed(){const e=[];for(const t of this.testCases)await t.passed()||e.push(t);return e}}const u=[],d=e=>{u.splice(0,u.length,...e)},p=async(e,t,s)=>{for(const e of s)try{e.actual=t.apply(null,e.inputs)}catch(t){e.error=t}const r=new l(e,s);for(const e of u)await e.report(r)},m=e=>new o(e,(async t=>e===t),(e=>`${e}`)),h=(e,t)=>{if(!t.hasOwnProperty("length"))return!1;if(t.length!==e.length)return!1;for(let s=0;s<e.length;s++){const r=e[s],a=t[s];if(Array.isArray(r)&&Array.isArray(a)){if(!h(r,a))return!1}else if(r!==a)return!1}return!0},f=e=>new o(e,(async t=>!!t&&h(e,t)),(e=>Array.isArray(e)?JSON.stringify(e):`${e}`)),y=e=>new r(e),g=e=>new a(e);function w(e){return!(!e||!e.then)&&new Promise((t=>{const s=setTimeout((()=>{t(!1)}),100);e.then((e=>{t(e===this.value.value)})).catch((()=>{t(!1)})).finally((()=>clearTimeout(s)))}))}function v(e){return!(!e||!e.then)&&new Promise((t=>{const s=setTimeout((()=>{t(!1)}),100);e.then((()=>{t(!1)})).catch((e=>{t(e===this.value.value)})).finally((()=>clearTimeout(s)))}))}const x=e=>e instanceof r?Promise.resolve(`Fulfilled promise(${e.value})`):e instanceof a?Promise.resolve(`Rejected promise(${e.value})`):e?e.then?new Promise((t=>{setTimeout((()=>{t("Promise not resolving")}),100),e.then((e=>{t(`Fulfulled promise(${e})`)})).catch((e=>{e instanceof Error?t(`Rejected promise with error\n${e.message}\n${e.stack}`):t(`Rejected promise(${e})`)}))})):"not a promise":"no value";class C{constructor(...e){this.params=e,this.actual=null}constructAPI(){return{params:this.params,registerCallback:e=>{this.actual=e(...this.params)}}}getValue(){return this.actual}}class ${constructor(e){this.value=e}}const E=(e,...t)=>{const s=new C(...t);return{expected:new o(e,(async()=>e.value===s.getValue()),(e=>e instanceof $?e.value:s.getValue())),input:new n(s.constructAPI(),"callback")}};export{$ as CallbackExpectedValue,t as ConsoleReporter,o as Expected,s as HtmlReporter,n as Input,a as PromiseReject,r as PromiseResolve,e as Reporter,c as TestCase,f as expectArray,E as expectCallback,m as expectValue,x as promiseFormatter,g as promiseReject,v as promiseRejectCheck,y as promiseResolve,w as promiseValueCheck,d as setReporters,p as verify};

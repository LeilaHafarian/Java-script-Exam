class e{constructor(e){this.value=e}}class t{constructor(e){this.value=e}}class s{constructor(e,t){this._value=e,this.type=t}get value(){return"promise-resolved"===this.type?Promise.resolve(this._value):"promise-rejected"===this.type?Promise.reject(this._value):this._value}get rawValue(){return this._value}}class r{constructor(e,t,s){this.value=e,this.check=t.bind(this),this.formatter=s}async formattedValue(){return this.formatter(this.value)}}const a=Symbol.for("TestCase.NoValue");class n{constructor(e,...t){this.expected=e,this._inputs=t,this.actual=a,this.storedPassed=a,this.error=a}async formattedActual(){return this.actual===a?"no value found":await this.expected.formatter(this.actual)}get hasError(){return this.error!==a}get inputs(){return this._inputs.map((e=>e instanceof s?e.value:e))}get inputsAsStrings(){return this._inputs.map((e=>{if(e instanceof s){if("promise-resolved"===e.type)return`Fulfilled promise(${e.rawValue})`;if("promise-rejected"===e.type)return`Rejected promise(${e.rawValue})`;if("callback"===e.type){return`callback(${e._value.params.map((e=>"object"==typeof e?JSON.stringify(e):`${e}`)).join(", ")})`}return"object"==typeof e.value?JSON.stringify(e.value):e.value}return"object"==typeof e?JSON.stringify(e):e}))}async passed(){return this.storedPassed!==a?this.storedPassed:this.error!==a?(this.storedPassed=!1,!1):(this.storedPassed=await this.expected.check(this.actual),this.storedPassed)}}class o{constructor(e,t){this.questionName=e,this.testCases=t}async passed(){return this.testCases.reduce((async(e,t)=>{const s=await e,r=await t.passed();return s&&r}),!0)}async listFailed(){const e=[];for(const t of this.testCases)await t.passed()||e.push(t);return e}}const i=[],c=e=>{i.splice(0,i.length,...e)},l=async(e,t,s)=>{for(const e of s)try{e.actual=t.apply(null,e.inputs)}catch(t){e.error=t}const r=new o(e,s);for(const e of i)await e.report(r)},u=e=>new r(e,(async t=>e===t),(e=>`${e}`)),d=(e,t)=>{if(!t.hasOwnProperty("length"))return!1;if(t.length!==e.length)return!1;for(let s=0;s<e.length;s++){const r=e[s],a=t[s];if(Array.isArray(r)&&Array.isArray(a)){if(!d(r,a))return!1}else if(r!==a)return!1}return!0},p=e=>new r(e,(async t=>!!t&&d(e,t)),(e=>Array.isArray(e)?JSON.stringify(e):`${e}`)),m=t=>new e(t),h=e=>new t(e);function f(e){return!(!e||!e.then)&&new Promise((t=>{const s=setTimeout((()=>{t(!1)}),100);e.then((e=>{t(e===this.value.value)})).catch((()=>{t(!1)})).finally((()=>clearTimeout(s)))}))}function y(e){return!(!e||!e.then)&&new Promise((t=>{const s=setTimeout((()=>{t(!1)}),100);e.then((()=>{t(!1)})).catch((e=>{t(e===this.value.value)})).finally((()=>clearTimeout(s)))}))}const g=s=>s instanceof e?Promise.resolve(`Fulfilled promise(${JSON.stringify(s.value)})`):s instanceof t?Promise.resolve(`Rejected promise(${JSON.stringify(s.value)})`):s?s.then?new Promise((e=>{setTimeout((()=>{e("Promise not resolving")}),100),s.then((t=>{e(`Fulfulled promise(${JSON.stringify(t)})`)})).catch((t=>{t instanceof Error?e(`Rejected promise with error\n${t.message}\n${t.stack}`):e(`Rejected promise(${JSON.stringify(t)})`)}))})):"not a promise":"no value";class w{constructor(...e){this.params=e,this.actual=null}constructAPI(){return{params:this.params,registerCallback:e=>{this.actual=e(...this.params)}}}getValue(){return this.actual}}class v{constructor(e){this.value=e}}const x=(e,...t)=>{const a=new w(...t);return{expected:new r(e,(async()=>e.value===a.getValue()),(e=>e instanceof v?e.value:a.getValue())),input:new s(a.constructAPI(),"callback")}};class C{async report(e){throw new Error("Implement method")}}class $ extends C{async report(e){if(await e.passed())console.log(`%cAll tests for ${e.questionName} passed`,"background-color: darkgreen; color: white; padding:0 5px;");else{console.group(`%cSome tests for ${e.questionName} failed`,"background-color: darkred; color: white; padding:0 5px;");for(const t of await e.listFailed()){const e=`Input: ${t.inputsAsStrings.join(", ")}. Expected: ${await t.expected.formattedValue()}`;t.hasError?console.log(`${e}.\nExpection occured. See error data below\n`,t.error):console.log(`${e}. Actual: ${await t.formattedActual()}`)}console.groupEnd()}}}class E extends C{constructor(){if(super(),this.element=document.getElementById("tests"),this.element){let e=document.getElementById("htmlReporterStyles");e||(e=document.createElement("style"),e.setAttribute("id","htmlReporterStyles"),e.textContent="\n        .summary { display: flex; flex-direction: column; margin-bottom: 10px; }\n        .testsHeader { padding: 10px 20px; font-family: sans-serif; }\n        .success .testsHeader { background-color: darkgreen; color: white; }\n        .fail .testsHeader { background-color: darkred; color: white; }\n        .testCaseWrapper { font-family: monospace; font-size: 1rem; padding: 10px; background-color: lightgrey; gap: 5px 30px; display: grid; grid-template-columns: auto auto auto; }\n        .testCaseWrapper > span { white-space: pre; }\n        ",document.head.appendChild(e))}else console.warn("HTML reporter found no base element. Will not report anything.")}async report(e){if(!this.element)return;const t=await e.passed(),s=document.createElement("div");s.classList.add("summary",t?"success":"fail");const r=document.createElement("span");if(r.classList.add("testsHeader"),r.textContent=t?`${e.questionName}: All tests passed`:`${e.questionName}: some tests failed`,s.appendChild(r),!await e.passed()){const t=document.createElement("div");t.classList.add("testCaseWrapper");const r=document.createElement("span");r.textContent="Inputs",t.appendChild(r);const a=document.createElement("span");a.textContent="Expected",t.appendChild(a);const n=document.createElement("span");n.textContent="Actual",t.appendChild(n);for(const s of await e.listFailed()){const e=document.createElement("span");e.textContent=s.inputsAsStrings.join(", "),t.appendChild(e);const r=document.createElement("span");r.textContent=await s.expected.formattedValue(),t.appendChild(r);const a=document.createElement("span");s.hasError?a.textContent=`Expection occured. See error data below\n${JSON.stringify(s.error.message)}\n${JSON.stringify(s.error.stack)}`:a.textContent=await s.formattedActual(),t.appendChild(a)}s.appendChild(t)}this.element.appendChild(s)}}export{v as CallbackExpectedValue,$ as ConsoleReporter,r as Expected,E as HtmlReporter,s as Input,t as PromiseReject,e as PromiseResolve,C as Reporter,n as TestCase,p as expectArray,x as expectCallback,u as expectValue,g as promiseFormatter,h as promiseReject,y as promiseRejectCheck,m as promiseResolve,f as promiseValueCheck,c as setReporters,l as verify};
